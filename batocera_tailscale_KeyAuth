#!/bin/bash
#
# Improved Tailscale Installation with SSH Key Authentication for Batocera Linux
# This script automates:
# 1. Tailscale installation on Batocera
# 2. SSH key-based authentication setup with automatic conversion
# 3. Configuration persistence across reboots
# 4. Handles Tailscale connection properly to prevent disconnection

# Color definitions for better visual feedback
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Define log function with timestamp and color
log() {
  local color=$1
  local message=$2
  echo -e "${color}[$(date '+%Y-%m-%d %H:%M:%S')] $message${NC}" | tee -a /userdata/system/logs/tailscale_sshkey_setup.log
}

# Show a simple progress bar
show_progress() {
  local duration=$1
  local total_steps=20
  local sleep_time=$(echo "$duration/$total_steps" | awk '{print $1}')
  
  echo -ne "${CYAN}["
  for ((i=0; i<$total_steps; i++)); do
    sleep $sleep_time
    echo -ne "#"
  done
  echo -e "]${NC}"
}

# Create directories needed for operation
create_dirs() {
  mkdir -p /userdata/system/logs
  mkdir -p /userdata/system/.ssh
  mkdir -p "/userdata/system/tailscale/keys"
  chmod 700 /userdata/system/.ssh
  chmod 700 /userdata/system/tailscale/keys
}

# Check permissions
check_permissions() {
  if [ ! -w "/userdata/system" ]; then
    log "${RED}" "Insufficient permissions to write to /userdata/system"
    log "${RED}" "Make sure you're running this from the Batocera terminal"
    exit 1
  fi
}

# Script initialization
clear
create_dirs
check_permissions

echo -e "${PURPLE}=========================================================${NC}"
echo -e "${PURPLE}   Tailscale and SSH Key Setup for Batocera Linux        ${NC}"
echo -e "${PURPLE}=========================================================${NC}"
echo ""
log "${BLUE}" "Starting setup process..."

# Parse command line arguments
TAILSCALE_ARGS=""
AUTO_CONNECT=false
AUTHKEY=""
HOSTNAME="batocera-pi"
ADVERTISE_ROUTES=""
ADVERTISE_EXIT_NODE=false
ACCEPT_ROUTES=false
AUTO_REBOOT=false
TAG=""

# Check for command line arguments
while [[ "$#" -gt 0 ]]; do
  case $1 in
    --authkey=*) AUTHKEY="${1#*=}"; AUTO_CONNECT=true; shift ;;
    --authkey) AUTHKEY="$2"; AUTO_CONNECT=true; shift 2 ;;
    --hostname=*) HOSTNAME="${1#*=}"; shift ;;
    --hostname) HOSTNAME="$2"; shift 2 ;;
    --advertise-routes=*) ADVERTISE_ROUTES="${1#*=}"; shift ;;
    --advertise-routes) ADVERTISE_ROUTES="$2"; shift 2 ;;
    --exit-node) ADVERTISE_EXIT_NODE=true; shift ;;
    --accept-routes) ACCEPT_ROUTES=true; shift ;;
    --auto-reboot) AUTO_REBOOT=true; shift ;;
    --tag=*) TAG="${1#*=}"; shift ;;
    --tag) TAG="$2"; shift 2 ;;
    --help) 
      echo -e "${GREEN}Usage: $0 [OPTIONS]${NC}"
      echo ""
      echo -e "${CYAN}Options:${NC}"
      echo "  --authkey=KEY             Provide Tailscale auth key for automatic connection"
      echo "  --hostname=NAME           Set hostname for this device (default: batocera-pi)"
      echo "  --advertise-routes=SUBNET Advertise subnet routes (e.g., 192.168.1.0/24)"
      echo "  --exit-node               Advertise this device as an exit node"
      echo "  --accept-routes           Accept subnet routes from other devices"
      echo "  --auto-reboot             Automatically reboot after installation"
      echo "  --tag=TAG                 Apply a Tailscale tag to this device"
      echo "  --help                    Show this help message"
      echo ""
      exit 0
      ;;
    *) log "${RED}" "Unknown parameter: $1"; exit 1 ;;
  esac
done

# Define variables
TEMP_DIR="/tmp/tailscale_install"
INSTALL_DIR="/userdata/system/tailscale"
SSH_DIR="/userdata/system/.ssh"
KEYS_DIR="/userdata/system/tailscale/keys"
TAILSCALE_DONE_FILE="/userdata/system/tailscale/.installed"
DROPBEAR_DIR="/etc/dropbear"
ARCH=$(uname -m)
VERSION="1.62.0"

# Set the correct Tailscale URL based on architecture
if [[ "$ARCH" == "aarch64" ]]; then
  TAILSCALE_URL="https://pkgs.tailscale.com/stable/tailscale_${VERSION}_arm64.tgz"
elif [[ "$ARCH" == "armv7l" ]]; then
  TAILSCALE_URL="https://pkgs.tailscale.com/stable/tailscale_${VERSION}_arm.tgz"
else
  log "${RED}" "Unsupported architecture: $ARCH"
  log "${RED}" "This script supports ARM64 (aarch64) and ARM (armv7l) architectures"
  exit 1
fi

# Check for required commands
check_prerequisites() {
  log "${BLUE}" "Checking prerequisites..."
  
  # Check for curl
  if ! command -v curl &> /dev/null; then
    log "${RED}" "Error: curl is required but not found."
    log "${YELLOW}" "Attempting to install curl..."
    
    # Try to install curl using available package manager
    if command -v pacman &> /dev/null; then
      pacman -S curl --noconfirm
    elif command -v batocera-store-install &> /dev/null; then
      batocera-store-install curl
    else
      log "${RED}" "Unable to install curl automatically. Please install manually."
      exit 1
    fi
    
    if ! command -v curl &> /dev/null; then
      log "${RED}" "Failed to install curl. Please install manually and try again."
      exit 1
    fi
  fi
  
  # Check for dropbear and dropbearkey
  if ! command -v dropbear &> /dev/null; then
    log "${RED}" "Error: dropbear is required but not found. Batocera should include this by default."
    exit 1
  fi
  
  if ! command -v dropbearkey &> /dev/null; then
    log "${RED}" "Error: dropbearkey is required but not found. Batocera should include this by default."
    exit 1
  fi
  
  # Check for dropbearconvert
  if ! command -v dropbearconvert &> /dev/null; then
    log "${YELLOW}" "Warning: dropbearconvert not found. Will try to use alternative methods."
  fi
  
  log "${GREEN}" "Prerequisites check completed!"
}

# Create directories
create_directories() {
  log "${BLUE}" "Step 1/9: Creating directories..."
  mkdir -p "$TEMP_DIR"
  mkdir -p "$INSTALL_DIR"
  mkdir -p "$INSTALL_DIR/state"
  mkdir -p "$SSH_DIR"
  mkdir -p "$KEYS_DIR"
  chmod 700 "$SSH_DIR"
  chmod 700 "$KEYS_DIR"
  log "${GREEN}" "Directories created successfully!"
}

# Detect subnet
detect_subnet() {
  log "${BLUE}" "Step 2/9: Detecting network subnet..."
  show_progress 1
  
  # Try to detect the local subnet
  local ip_cmd_output
  local gateway
  local subnet
  
  ip_cmd_output=$(ip route | grep default)
  if [ -n "$ip_cmd_output" ]; then
    gateway=$(echo "$ip_cmd_output" | grep -oE 'via [0-9.]+' | cut -d' ' -f2)
    # Get the device from the default route
    local device=$(echo "$ip_cmd_output" | grep -oE 'dev [^ ]+' | cut -d' ' -f2)
    
    if [ -n "$device" ]; then
      # Get the subnet from the device
      subnet=$(ip route | grep "src" | grep "$device" | grep -v "default" | head -n1 | grep -oE '[0-9.]+/[0-9]+' | head -n1)
    fi
  fi
  
  if [ -z "$subnet" ]; then
    subnet=$(ip addr | grep -E "inet .* brd .* scope global" | head -n1 | awk '{print $2}' | grep -oE '[0-9.]+/[0-9]+')
  fi
  
  if [ -n "$subnet" ]; then
    log "${GREEN}" "‚úÖ Detected: $subnet"
    echo -e "${YELLOW}Note: Only one device can advertise this subnet${NC}"
    
    # Ask to use this subnet if no subnet was provided via command line
    if [ -z "$ADVERTISE_ROUTES" ]; then
      echo -ne "Would you like to advertise this subnet? (yes/no): "
      read -r advertise_answer
      if [[ "$advertise_answer" =~ ^[Yy][Ee][Ss]$ ]]; then
        ADVERTISE_ROUTES="$subnet"
        log "${GREEN}" "‚úÖ Will advertise subnet: $subnet"
      else
        log "${YELLOW}" "Not advertising subnet"
      fi
    fi
  else
    log "${YELLOW}" "Could not detect subnet automatically"
  fi
}

# Set up hostname
setup_hostname() {
  # Ask for hostname if not provided
  if [ "$HOSTNAME" == "batocera-pi" ] && [ -z "$AUTO_CONNECT" ]; then
    echo -ne "Enter a hostname (default: $HOSTNAME): "
    read -r new_hostname
    if [ -n "$new_hostname" ]; then
      HOSTNAME="$new_hostname"
    fi
  fi
  
  log "${GREEN}" "‚úÖ Using hostname: $HOSTNAME"
  
  # Ask for tag if not provided
  if [ -z "$TAG" ] && [ -z "$AUTO_CONNECT" ]; then
    echo -ne "Enter Tailscale tag (optional, press Enter to skip): "
    read -r new_tag
    if [ -n "$new_tag" ]; then
      TAG="$new_tag"
      log "${GREEN}" "‚úÖ Using tag: $TAG"
    else
      log "${YELLOW}" "No tag specified"
    fi
  elif [ -n "$TAG" ]; then
    log "${GREEN}" "‚úÖ Using tag: $TAG"
  fi
}

# Setup authkey
setup_authkey() {
  # Ask for authkey if not provided
  if [ -z "$AUTHKEY" ]; then
    log "${CYAN}" "üîë Generate a key at https://login.tailscale.com/admin/settings/keys"
    echo -ne "Enter Tailscale auth key (tskey-auth-...): "
    read -r AUTHKEY
    
    if [ -z "$AUTHKEY" ]; then
      log "${RED}" "No auth key provided, cannot continue"
      exit 1
    fi
  fi
}

# Generate or setup SSH keys
setup_ssh_keys() {
  log "${BLUE}" "Step 3/9: Setting up SSH keys..."
  
  # Generate dropbear keys
  log "${YELLOW}" "Generating SSH key pair with dropbearkey..."
  show_progress 1
  
  # Generate dropbear key
  if [ -f "$SSH_DIR/id_dropbear" ]; then
    log "${YELLOW}" "Existing Dropbear key found, backing up..."
    cp "$SSH_DIR/id_dropbear" "$SSH_DIR/id_dropbear.bak"
  fi
  
  # Generate new key
  dropbearkey -t ed25519 -f "$SSH_DIR/id_dropbear" 2>/dev/null
  
  if [ ! -f "$SSH_DIR/id_dropbear" ]; then
    log "${RED}" "Failed to generate ED25519 key, trying RSA..."
    dropbearkey -t rsa -s 4096 -f "$SSH_DIR/id_dropbear" 2>/dev/null
    
    if [ ! -f "$SSH_DIR/id_dropbear" ]; then
      log "${RED}" "Failed to generate SSH keys. Exiting."
      exit 1
    fi
  fi
  
  chmod 600 "$SSH_DIR/id_dropbear"
  
  # Extract public key and create authorized_keys
  dropbearkey -y -f "$SSH_DIR/id_dropbear" | grep "^ssh-" > "$SSH_DIR/authorized_keys"
  chmod 600 "$SSH_DIR/authorized_keys"
  
  log "${GREEN}" "‚úÖ SSH key pair generated"
  log "${GREEN}" "‚úÖ Public key added‚Äîkey auth enabled on reboot"
  
  # Convert key to OpenSSH format if dropbearconvert is available
  convert_and_save_key
}

# Convert and save key in a user-friendly way
convert_and_save_key() {
  local openssh_key="$KEYS_DIR/id_ed25519"
  local openssh_key_pub="$KEYS_DIR/id_ed25519.pub"
  local instructions_file="$KEYS_DIR/SSH_INSTRUCTIONS.txt"
  
  # Try to convert the key to OpenSSH format
  if command -v dropbearconvert &> /dev/null; then
    log "${CYAN}" "Converting Dropbear key to OpenSSH format..."
    
    if dropbearconvert dropbear openssh "$SSH_DIR/id_dropbear" "$openssh_key" 2>/dev/null; then
      chmod 600 "$openssh_key"
      
      # Extract public key if we have the private key
      if [ -f "$openssh_key" ]; then
        # Extract content from authorized_keys
        cat "$SSH_DIR/authorized_keys" > "$openssh_key_pub"
        chmod 644 "$openssh_key_pub"
      fi
      
      log "${GREEN}" "‚úÖ SSH key converted to OpenSSH format"
      log "${GREEN}" "‚úÖ Saved to $openssh_key"
    else
      log "${RED}" "‚ùå Failed to convert key automatically"
    fi
  else
    log "${YELLOW}" "dropbearconvert not available, cannot automatically convert key"
    # Copy the raw key for manual conversion
    cp "$SSH_DIR/id_dropbear" "$KEYS_DIR/id_dropbear.raw"
    chmod 600 "$KEYS_DIR/id_dropbear.raw"
  fi
  
  # Create instructions file regardless of conversion success
  create_ssh_instructions "$instructions_file"
}

# Create detailed SSH instructions file
create_ssh_instructions() {
  local instructions_file="$1"
  local public_key=$(cat "$SSH_DIR/authorized_keys")
  local device_hostname=$(hostname)
  
  # Create the instructions file
  cat > "$instructions_file" << EOF
=======================================================================
               SSH KEY AUTHENTICATION INSTRUCTIONS
=======================================================================

Your Batocera system is now configured with key-based SSH authentication
for enhanced security. Password authentication will be disabled after reboot.

PUBLIC KEY:
$public_key

KEY FILES LOCATION ON BATOCERA:
- Private key (Dropbear format): /userdata/system/.ssh/id_dropbear
- Converted key (OpenSSH format): /userdata/system/tailscale/keys/id_ed25519
- Public key: /userdata/system/tailscale/keys/id_ed25519.pub
- This instructions file: /userdata/system/tailscale/keys/SSH_INSTRUCTIONS.txt

CONNECTING FROM LINUX/MAC:
1. Copy the OpenSSH private key to your computer:
   scp root@$device_hostname:/userdata/system/tailscale/keys/id_ed25519 ~/.ssh/batocera_key

2. Set proper permissions:
   chmod 600 ~/.ssh/batocera_key

3. Connect using the key:
   ssh -i ~/.ssh/batocera_key root@<tailscale-ip>

CONNECTING FROM WINDOWS:
1. Use WinSCP or SFTP to download the converted key
2. Use the key with PuTTY or other SSH clients

TROUBLESHOOTING:
If you're unable to connect after reboot, you can temporarily re-enable 
password authentication by editing custom.sh from EmulationStation:

1. Press START in EmulationStation
2. Go to System Settings > Developer > File Manager
3. Navigate to /userdata/system/
4. Edit custom.sh and remove or comment out the "# Disable password auth" section
5. Save and reboot

=======================================================================
EOF

  chmod 644 "$instructions_file"
  log "${GREEN}" "‚úÖ Created SSH instructions file at $instructions_file"
}

# Download Tailscale
download_tailscale() {
  log "${BLUE}" "Step 4/9: Downloading Tailscale v${VERSION}..."
  echo -e "${YELLOW}Downloading from: ${TAILSCALE_URL}${NC}"
  
  if ! curl -fsSL "$TAILSCALE_URL" -o "$TEMP_DIR/tailscale.tgz"; then
    log "${RED}" "Error: Failed to download Tailscale. Check your internet connection."
    exit 1
  fi
  
  log "${GREEN}" "‚úÖ Tailscale download completed successfully!"
}

# Extract and install Tailscale
install_tailscale() {
  log "${BLUE}" "Step 5/9: Installing Tailscale..."
  
  if ! tar -xzf "$TEMP_DIR/tailscale.tgz" -C "$TEMP_DIR"; then
    log "${RED}" "Error: Failed to extract Tailscale archive."
    exit 1
  fi
  
  # Move the extracted files to the installation directory
  cp -a "$TEMP_DIR"/tailscale_${VERSION}_*/tailscale "$INSTALL_DIR/"
  cp -a "$TEMP_DIR"/tailscale_${VERSION}_*/tailscaled "$INSTALL_DIR/"
  
  # Make the binaries executable
  chmod +x "$INSTALL_DIR/tailscale"
  chmod +x "$INSTALL_DIR/tailscaled"
  
  log "${GREEN}" "‚úÖ Tailscale installed successfully!"
}

# Configure network for routing
configure_network() {
  log "${BLUE}" "Step 6/9: Configuring network..."
  show_progress 1
  
  # Enable IP forwarding if needed for subnet routing
  if [ -n "$ADVERTISE_ROUTES" ] || [ "$ADVERTISE_EXIT_NODE" = true ]; then
    # Enable IP forwarding
    echo "net.ipv4.ip_forward = 1" > /etc/sysctl.d/99-tailscale.conf
    echo "net.ipv6.conf.all.forwarding = 1" >> /etc/sysctl.d/99-tailscale.conf
    
    # Apply sysctl settings
    sysctl -p /etc/sysctl.d/99-tailscale.conf
    
    log "${GREEN}" "‚úÖ IP forwarding enabled for routing"
  fi
}

# Configure Tailscale and SSH persistence
configure_persistence() {
  log "${BLUE}" "Step 7/9: Configuring persistence..."
  
  # Create startup script
  cat > "$INSTALL_DIR/start_tailscale.sh" << 'EOF'
#!/bin/sh
INSTALL_DIR="/userdata/system/tailscale"
SSH_DIR="/userdata/system/.ssh"
DROPBEAR_DIR="/etc/dropbear"

# Create Dropbear directory if it doesn't exist
mkdir -p "$DROPBEAR_DIR"

# Link SSH keys to Dropbear
if [ -f "$SSH_DIR/authorized_keys" ]; then
  ln -sf "$SSH_DIR/authorized_keys" "$DROPBEAR_DIR/authorized_keys"
  chmod 700 "$DROPBEAR_DIR"
  chmod 600 "$DROPBEAR_DIR/authorized_keys"
fi

# Configure Dropbear for key-based auth only
if [ -f /etc/default/dropbear ]; then
  # Backup original config if it exists and we haven't backed it up yet
  if [ ! -f /etc/default/dropbear.orig ]; then
    cp /etc/default/dropbear /etc/default/dropbear.orig
  fi
  
  # Modify to disable password authentication after reboot
  sed -i 's/^DROPBEAR_EXTRA_ARGS=.*/DROPBEAR_EXTRA_ARGS="-s -g"/' /etc/default/dropbear
fi

# Start tailscaled in the background
"$INSTALL_DIR/tailscaled" --state="$INSTALL_DIR/state/tailscaled.state" --socket="$INSTALL_DIR/tailscaled.sock" &

# Wait for the socket to be created
sleep 5

# Try to reconnect using saved state with SSH enabled
"$INSTALL_DIR/tailscale" --socket="$INSTALL_DIR/tailscaled.sock" up --ssh --reset
EOF
  
  # Make the startup script executable
  chmod +x "$INSTALL_DIR/start_tailscale.sh"
  
  # Create or update custom.sh
  if [ ! -f /userdata/system/custom.sh ]; then
    echo "#!/bin/sh" > /userdata/system/custom.sh
    chmod +x /userdata/system/custom.sh
  else
    # Backup custom.sh
    cp /userdata/system/custom.sh /userdata/system/custom.sh.bak
    log "${YELLOW}" "Backed up existing custom.sh to custom.sh.bak"
  fi
  
  # Make sure custom.sh ends with a newline
  if [ -s /userdata/system/custom.sh ] && [ "$(tail -c 1 /userdata/system/custom.sh | wc -l)" -eq 0 ]; then
    echo "" >> /userdata/system/custom.sh
  fi
  
  # Add Tailscale startup to custom.sh if not already there
  if ! grep -q "start_tailscale.sh" /userdata/system/custom.sh; then
    echo "# Start Tailscale" >> /userdata/system/custom.sh
    echo "$INSTALL_DIR/start_tailscale.sh &" >> /userdata/system/custom.sh
    log "${GREEN}" "‚úÖ Added Tailscale to startup scripts!"
  fi
  
  log "${GREEN}" "‚úÖ Persistence configured!"
}

# Start Tailscale and connect to network
start_tailscale() {
  log "${BLUE}" "Step 8/9: Starting Tailscale service..."
  
  # Kill any existing tailscaled process
  if pgrep tailscaled > /dev/null; then
    pkill tailscaled
    sleep 2
  fi
  
  # Start the tailscale daemon
  "$INSTALL_DIR/tailscaled" --state="$INSTALL_DIR/state/tailscaled.state" --socket="$INSTALL_DIR/tailscaled.sock" &
  
  # Wait for the socket to be created
  sleep 3
  
  # Save the PID
  local tailscaled_pid=$(pgrep tailscaled)
  
  # Check if tailscaled is running
  if [ -n "$tailscaled_pid" ]; then
    log "${GREEN}" "‚úÖ tailscaled started (PID: $tailscaled_pid)"
  else
    log "${RED}" "Warning: Tailscale daemon did not start properly."
    return 1
  fi
  
  # Build up tailscale command with all options
  local ts_cmd="$INSTALL_DIR/tailscale --socket=\"$INSTALL_DIR/tailscaled.sock\" up --hostname=\"$HOSTNAME\" --ssh"
  
  # Add tag if specified
  if [ -n "$TAG" ]; then
    ts_cmd="$ts_cmd --advertise-tags=\"$TAG\""
  fi
  
  # Add subnet routes if specified
  if [ -n "$ADVERTISE_ROUTES" ]; then
    ts_cmd="$ts_cmd --advertise-routes=\"$ADVERTISE_ROUTES\""
  fi
  
  # Add exit node flag if specified
  if [ "$ADVERTISE_EXIT_NODE" = true ]; then
    ts_cmd="$ts_cmd --advertise-exit-node"
  fi
  
  # Add accept routes flag if specified
  if [ "$ACCEPT_ROUTES" = true ]; then
    ts_cmd="$ts_cmd --accept-routes"
  fi
  
  # Add auth key if provided
  if [ -n "$AUTHKEY" ]; then
    ts_cmd="$ts_cmd --authkey=\"$AUTHKEY\""
  fi
  
  # Run the tailscale up command
  log "${YELLOW}" "Executing: tailscale up with appropriate flags..."
  eval "$ts_cmd"
  
  # Check if connect was successful by checking if tailscale is running
  sleep 2
  if "$INSTALL_DIR/tailscale" --socket="$INSTALL_DIR/tailscaled.sock" status &>/dev/null; then
    log "${GREEN}" "‚úÖ Tailscale up executed"
    
    # Create a file indicating Tailscale was installed
    touch "$TAILSCALE_DONE_FILE"
    
    return 0
  else
    log "${RED}" "‚ùå Failed to connect to Tailscale network"
    return 1
  fi
}

# Clean up temporary files
cleanup() {
  log "${BLUE}" "Step 9/9: Cleaning up..."
  rm -rf "$TEMP_DIR"
  log "${GREEN}" "‚úÖ Cleanup completed!"
}

# Verify installation
verify_installation() {
  log "${BLUE}" "Verifying installation..."
  show_progress 1
  
  local errors=0
  local tailscale_ip=""
  
  # Check Tailscale binaries
  if [ ! -f "$INSTALL_DIR/tailscale" ] || [ ! -f "$INSTALL_DIR/tailscaled" ]; then
    log "${RED}" "‚ùå Verification failed: Tailscale binaries not found."
    errors=$((errors+1))
  fi
  
  # Check Tailscale daemon
  if ! pgrep tailscaled > /dev/null; then
    log "${RED}" "‚ùå Verification failed: Tailscale daemon is not running."
    errors=$((errors+1))
  else
    # Get Tailscale IP
    tailscale_ip=$("$INSTALL_DIR/tailscale" --socket="$INSTALL_DIR/tailscaled.sock" ip -4 2>/dev/null)
    if [ -n "$tailscale_ip" ]; then
      log "${GREEN}" "Tailscale running at IP: $tailscale_ip"
      
      # Show Tailscale status
      "$INSTALL_DIR/tailscale" --socket="$INSTALL_DIR/tailscaled.sock" status
    else
      log "${RED}" "‚ùå Verification failed: Tailscale IP not available."
      errors=$((errors+1))
    fi
  fi
  
  # Check SSH key setup
  if [ ! -f "$SSH_DIR/authorized_keys" ]; then
    log "${RED}" "‚ùå Verification failed: SSH authorized_keys not found."
    errors=$((errors+1))
  fi
  
  # Check network interface
  ip addr show tailscale0 2>/dev/null || log "${RED}" "‚ùå Verification warning: tailscale0 interface not found."
  
  if [ $errors -eq 0 ]; then
    log "${GREEN}" "‚úÖ Verification successful: Tailscale and SSH keys are properly installed!"
    return 0
  else
    log "${RED}" "‚ùå Verification found $errors issue(s). Some manual configuration may be needed."
    return 1
  fi
}

# Show detailed information and next steps
show_info() {
  local tailscale_ip=$("$INSTALL_DIR/tailscale" --socket="$INSTALL_DIR/tailscaled.sock" ip -4 2>/dev/null)
  local openssh_key="$KEYS_DIR/id_ed25519"
  
  echo -e "${PURPLE}=========================================================${NC}"
  echo -e "${PURPLE}          Tailscale & SSH Key Setup Complete!           ${NC}"
  echo -e "${PURPLE}=========================================================${NC}"
  
  # Show Tailscale IP
  if [ -n "$tailscale_ip" ]; then
    echo -e "${CYAN}Tailscale IP:${NC} $tailscale_ip"
  else
    echo -e "${YELLOW}Tailscale IP:${NC} Not yet available"
  fi
  
  # Show SSH connection info
  echo -e "\n${CYAN}SSH CONNECTION INFORMATION:${NC}"
  
  if [ -f "$openssh_key" ]; then
    echo -e "${GREEN}‚úÖ SSH key successfully converted to OpenSSH format${NC}"
    echo -e "Private key: ${YELLOW}$openssh_key${NC}"
    echo -e "Connect after reboot with: ${YELLOW}ssh -i <path/to/copied/key> root@$tailscale_ip${NC}"
  else
    echo -e "${YELLOW}‚ö†Ô∏è SSH key conversion not completed automatically${NC}"
    echo -e "Raw key available at: ${YELLOW}$KEYS_DIR/id_dropbear.raw${NC}"
  fi
  
  # Explain what happens next
  echo -e "\n${CYAN}NEXT STEPS:${NC}"
  echo -e "1. ${GREEN}Copy the SSH key to your computer${NC} (instructions in $KEYS_DIR/SSH_INSTRUCTIONS.txt)"
  echo -e "2. ${GREEN}Reboot Batocera${NC} to enable key-based authentication"
  echo -e "3. ${GREEN}Connect via SSH${NC} using the key instead of password"
  
  # Warn about password auth being disabled
  echo -e "\n${YELLOW}IMPORTANT: Password authentication will be disabled after reboot.${NC}"
  echo -e "${YELLOW}Make sure you have copied the SSH key before rebooting!${NC}"
  
  # Show reboot option
  if [ "$AUTO_REBOOT" = false ]; then
    echo -e "\n${PURPLE}=========================================================${NC}"
    echo -ne "${GREEN}Would you like to reboot now? (yes/no):${NC} "
    read -r reboot_answer
    if [[ "$reboot_answer" =~ ^[Yy][Ee][Ss]$ ]]; then
      echo -e "${YELLOW}Rebooting system...${NC}"
      sleep 2
      reboot
    else
      echo -e "${YELLOW}Remember to reboot to complete the installation.${NC}"
    fi
  else
    echo -e "\n${YELLOW}Auto-reboot enabled. System will reboot in 10 seconds...${NC}"
    sleep 10
    reboot