#!/bin/bash
# Batocera Tailscale & SSH Setup
# Version: 19.4 - CRITICAL FIX: Never kills user's SSH session

# Use pipefail but NOT -e (we handle errors manually)
set -uo pipefail

########################################
# Colors & logging
########################################
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
NC='\033[0m'

log_info()    { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[OK]${NC} $1"; }
log_warn()    { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error()   { echo -e "${RED}[ERROR]${NC} $1"; }

banner() {
    echo ""
    echo -e "${BLUE}================================================================${NC}"
    echo -e "${BOLD}${MAGENTA}  $1${NC}"
    echo -e "${BLUE}================================================================${NC}"
    echo ""
}

spinner() {
    local pid=$1
    local message="$2"
    local spin='|/-\'
    local i=0

    while kill -0 "$pid" 2>/dev/null; do
        printf "\r${CYAN}%s${NC} %s" "${spin:i++%4:1}" "$message"
        sleep 0.2
    done
    wait "$pid"
    local exit_code=$?
    printf "\r"
    return $exit_code
}

run_with_spinner() {
    local message="$1"
    shift

    "$@" &>/dev/null &
    local pid=$!
    spinner "$pid" "$message"
    local result=$?

    if [[ $result -eq 0 ]]; then
        echo -e "${GREEN}[OK]${NC} $message"
    else
        echo -e "${RED}[FAIL]${NC} $message"
    fi
    return $result
}

# Safe pkill for port 2222 test server ONLY
# NEVER use this for main dropbear on port 22!
kill_test_dropbear() {
    pkill -f "dropbear.*2222" 2>/dev/null || true
    sleep 1
}

wait_for() {
    local condition="$1"
    local timeout="${2:-30}"
    local interval="${3:-2}"
    local elapsed=0

    while [[ $elapsed -lt $timeout ]]; do
        if eval "$condition" 2>/dev/null; then
            return 0
        fi
        sleep "$interval"
        elapsed=$((elapsed + interval))
    done
    return 1
}

########################################
# Paths & defaults
########################################
INSTALL_DIR="/userdata/system/tailscale"
BIN_DIR="$INSTALL_DIR/bin"
SSH_DIR="/userdata/system/.ssh"
KEYS_DIR="$INSTALL_DIR/keys"
DROPBEAR_KEY="$SSH_DIR/id_dropbear"
STATE_FILE="$INSTALL_DIR/tailscaled.state"
SOCK_FILE="$INSTALL_DIR/tailscaled.sock"
CUSTOM_SH="/userdata/system/custom.sh"
LOG_FILE="/tmp/tailscale-setup.log"

# Globals filled during configuration
LOCAL_IP=""
TAILSCALE_VERSION=""
AUTH_KEY=""
HOSTNAME=""
TAG=""
AUTH_MODE=""
SUBNET_ENABLE="no"
SUBNET=""
EXIT_NODE_ENABLE="no"
TAILSCALE_IP=""
OPENSSH_KEY=""

: > "$LOG_FILE"

########################################
# Cleanup on exit - ONLY kills test server
########################################
cleanup() {
    kill_test_dropbear
}
trap cleanup EXIT

########################################
# Pre-flight checks
########################################
preflight_checks() {
    banner "Pre-flight Checks"

    if [[ "$(id -u)" -ne 0 ]]; then
        log_error "This script must be run as root"
        exit 1
    fi
    log_success "Running as root"

    log_info "Checking internet connectivity..."
    if ! ping -c 2 -W 5 8.8.8.8 &>/dev/null; then
        log_error "No internet connection. Please connect and try again."
        exit 1
    fi
    log_success "Internet connection OK"

    local missing_tools=()
    for tool in curl wget tar grep awk; do
        if ! command -v "$tool" &>/dev/null; then
            missing_tools+=("$tool")
        fi
    done

    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        log_error "Missing required tools: ${missing_tools[*]}"
        exit 1
    fi
    log_success "Required tools available"

    LOCAL_IP=$(ip -4 addr show 2>/dev/null | grep -oE "inet [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" | awk '{print $2}' | grep -v "127.0.0.1" | head -n 1 || true)
    if [[ -z "$LOCAL_IP" ]]; then
        LOCAL_IP=$(hostname -I 2>/dev/null | awk '{print $1}' || true)
    fi

    if [[ -z "$LOCAL_IP" || ! "$LOCAL_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        log_warn "Could not auto-detect local IP"
        read -rp "Enter your device's local IP address: " LOCAL_IP
        if [[ ! "$LOCAL_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            log_error "Invalid IP format"
            exit 1
        fi
    fi
    log_success "Local IP: $LOCAL_IP"
}

########################################
# Get latest Tailscale version
########################################
get_tailscale_version() {
    log_info "Detecting latest Tailscale version..."

    TAILSCALE_VERSION=$(curl -s --connect-timeout 10 "https://pkgs.tailscale.com/stable/" 2>/dev/null \
        | grep -oP 'tailscale_\K[0-9]+\.[0-9]+\.[0-9]+(?=_arm64\.tgz)' \
        | sort -V | tail -n 1 || true)

    if [[ -z "$TAILSCALE_VERSION" ]]; then
        TAILSCALE_VERSION="1.80.2"
        log_warn "Could not fetch latest version, using fallback: $TAILSCALE_VERSION"
    else
        log_success "Latest version: $TAILSCALE_VERSION"
    fi
}

########################################
# Configuration prompts
########################################
configure_tailscale() {
    banner "Tailscale Configuration"

    echo -e "${CYAN}You need a Tailscale auth key from:${NC}"
    echo -e "${CYAN}  https://login.tailscale.com/admin/settings/keys${NC}"
    echo ""

    while true; do
        read -rp "Enter your Tailscale auth key (tskey-auth-...): " AUTH_KEY
        if [[ -z "$AUTH_KEY" ]]; then
            log_error "Auth key is required"
        elif [[ ! "$AUTH_KEY" =~ ^tskey-auth- ]]; then
            log_error "Invalid auth key format (should start with tskey-auth-)"
        else
            break
        fi
    done

    local DEFAULT_HOSTNAME
    DEFAULT_HOSTNAME=$(hostname | cut -d'.' -f1)
    read -rp "Hostname for this device [${DEFAULT_HOSTNAME}]: " USER_HOSTNAME
    HOSTNAME="${USER_HOSTNAME:-$DEFAULT_HOSTNAME}"

    echo ""
    echo -e "${BOLD}Tailscale Tags${NC}"
    echo "Tags help organize devices in your Tailscale admin console."
    echo "  1) No tag (recommended for most users)"
    echo "  2) Use tag: tag:ssh-batocera"
    echo "  3) Custom tag"
    read -rp "Select [1]: " TAG_CHOICE

    case "${TAG_CHOICE:-1}" in
        2) TAG="tag:ssh-batocera" ;;
        3)
            read -rp "Enter custom tag (e.g., tag:gaming): " TAG
            [[ -z "$TAG" ]] && TAG=""
            ;;
        *) TAG="" ;;
    esac
}

configure_ssh() {
    banner "SSH Configuration"

    echo -e "${BOLD}SSH Authentication Method${NC}"
    echo "  1) Password only (easiest - uses root/linux)"
    echo "  2) SSH key only (more secure - we'll generate a key)"
    echo "  3) Both password and key (flexibility)"
    read -rp "Select [1]: " SSH_CHOICE

    case "${SSH_CHOICE:-1}" in
        2) AUTH_MODE="key_only" ;;
        3) AUTH_MODE="both" ;;
        *) AUTH_MODE="password" ;;
    esac

    log_info "SSH mode: $AUTH_MODE"
}

configure_advanced() {
    banner "Advanced Options"

    echo -e "${BOLD}Subnet Routing${NC}"
    echo "Allow access to your local network through Tailscale?"
    read -rp "Enable subnet routing? (y/N): " SUBNET_CHOICE

    SUBNET_ENABLE="no"
    SUBNET=""

    if [[ "${SUBNET_CHOICE,,}" =~ ^y ]]; then
        local GATEWAY_IP
        GATEWAY_IP=$(ip route show default 2>/dev/null | awk '/default/ {print $3; exit}' || true)
        if [[ -n "$GATEWAY_IP" ]]; then
            local AUTO_SUBNET
            AUTO_SUBNET=$(echo "$GATEWAY_IP" | awk -F. '{print $1"."$2"."$3".0/24"}')
            echo "Detected subnet: $AUTO_SUBNET"
            read -rp "Use this subnet? (Y/n): " USE_AUTO
            if [[ ! "${USE_AUTO,,}" =~ ^n ]]; then
                SUBNET="$AUTO_SUBNET"
            fi
        fi

        if [[ -z "$SUBNET" ]]; then
            read -rp "Enter subnet (e.g., 192.168.1.0/24): " SUBNET
        fi

        if [[ "$SUBNET" =~ ^[0-9]{1,3}(\.[0-9]{1,3}){3}/[0-9]{1,2}$ ]]; then
            SUBNET_ENABLE="yes"
            log_success "Subnet routing: $SUBNET"
        else
            log_warn "Invalid subnet format, skipping subnet routing"
            SUBNET=""
        fi
    fi

    echo ""
    echo -e "${BOLD}Exit Node${NC}"
    echo "Make this device an exit node (route internet traffic through it)?"
    read -rp "Enable exit node? (y/N): " EXIT_CHOICE

    if [[ "${EXIT_CHOICE,,}" =~ ^y ]]; then
        EXIT_NODE_ENABLE="yes"
        log_info "Exit node will be enabled (requires approval in Tailscale admin)"
    else
        EXIT_NODE_ENABLE="no"
    fi
}

########################################
# Installation
########################################
install_tailscale() {
    banner "Installing Tailscale"

    log_info "Downloading Tailscale $TAILSCALE_VERSION..."
    mkdir -p "$BIN_DIR"

    local tarball="$INSTALL_DIR/tailscale.tgz"
    local url="https://pkgs.tailscale.com/stable/tailscale_${TAILSCALE_VERSION}_arm64.tgz"

    if ! wget -q -O "$tarball" "$url"; then
        log_error "Download failed"
        exit 1
    fi

    log_info "Extracting..."
    if ! tar -xzf "$tarball" -C "$BIN_DIR" --strip-components=1; then
        log_error "Extraction failed"
        exit 1
    fi
    rm -f "$tarball"

    chmod +x "$BIN_DIR/tailscale" "$BIN_DIR/tailscaled"
    log_success "Tailscale installed to $BIN_DIR"
}

start_tailscale() {
    banner "Starting Tailscale"

    # Kill any existing tailscaled (this is safe - it's not our SSH connection)
    pkill -f "tailscaled" 2>/dev/null || true
    sleep 2

    mkdir -p /var/run/tailscale /dev/net

    if [[ ! -c /dev/net/tun ]]; then
        mknod /dev/net/tun c 10 200 2>/dev/null || true
        chmod 600 /dev/net/tun
    fi

    ln -sf "$SOCK_FILE" /var/run/tailscale/tailscaled.sock 2>/dev/null || true

    log_info "Starting tailscaled daemon..."
    "$BIN_DIR/tailscaled" \
        --state="$STATE_FILE" \
        --socket="$SOCK_FILE" \
        --tun=userspace-networking \
        --verbose=1 >> "$LOG_FILE" 2>&1 &

    log_info "Waiting for daemon to initialize..."
    if ! wait_for "test -S '$SOCK_FILE'" 30 2; then
        log_error "Tailscaled failed to start. Check $LOG_FILE"
        exit 1
    fi

    sleep 5
    log_success "Tailscaled running"

    local -a ts_args=("--authkey=$AUTH_KEY" "--hostname=$HOSTNAME" "--accept-routes")

    [[ -n "$TAG" ]] && ts_args+=("--advertise-tags=$TAG")
    [[ "$SUBNET_ENABLE" == "yes" ]] && ts_args+=("--advertise-routes=$SUBNET")
    [[ "$EXIT_NODE_ENABLE" == "yes" ]] && ts_args+=("--advertise-exit-node")

    log_info "Connecting to Tailscale network..."
    if ! "$BIN_DIR/tailscale" --socket="$SOCK_FILE" up "${ts_args[@]}" >> "$LOG_FILE" 2>&1; then
        log_error "Failed to connect. Check $LOG_FILE"
        cat "$LOG_FILE"
        exit 1
    fi

    log_info "Waiting for Tailscale IP..."
    local tries=0
    TAILSCALE_IP=""
    while [[ -z "$TAILSCALE_IP" && $tries -lt 15 ]]; do
        sleep 2
        TAILSCALE_IP=$("$BIN_DIR/tailscale" --socket="$SOCK_FILE" ip -4 2>/dev/null || true)
        ((tries++))
    done

    if [[ -n "$TAILSCALE_IP" ]]; then
        log_success "Tailscale IP: $TAILSCALE_IP"
    else
        log_warn "Could not get Tailscale IP yet (may appear after reboot)"
        TAILSCALE_IP="(pending)"
    fi
}

########################################
# SSH Setup
########################################
setup_ssh_keys() {
    if [[ "$AUTH_MODE" == "password" ]]; then
        return 0
    fi

    banner "SSH Key Setup"

    mkdir -p "$SSH_DIR" "$KEYS_DIR" /etc/dropbear
    chmod 700 "$SSH_DIR" "$KEYS_DIR" /etc/dropbear

    if [[ ! -f "$DROPBEAR_KEY" ]]; then
        log_info "Generating SSH key..."
        if ! dropbearkey -t ed25519 -f "$DROPBEAR_KEY" &>/dev/null; then
            log_error "Key generation failed"
            return 1
        fi
        chmod 600 "$DROPBEAR_KEY"
    fi

    dropbearkey -y -f "$DROPBEAR_KEY" 2>/dev/null | grep "^ssh-ed25519" > /etc/dropbear/authorized_keys
    chmod 600 /etc/dropbear/authorized_keys

    OPENSSH_KEY="$KEYS_DIR/id_ed25519_${HOSTNAME}"
    if ! dropbearconvert dropbear openssh "$DROPBEAR_KEY" "$OPENSSH_KEY" &>/dev/null; then
        log_error "Key conversion failed"
        return 1
    fi
    chmod 600 "$OPENSSH_KEY"

    log_success "SSH key generated: $OPENSSH_KEY"
}

configure_dropbear() {
    banner "Configuring SSH Server"

    mkdir -p /etc/dropbear

    # ============================================================
    # CRITICAL: We ONLY update the config file here.
    # We NEVER kill, restart, or touch the running dropbear!
    # Doing so would terminate this SSH session and lock out the user.
    # The new config takes effect after reboot.
    # ============================================================

    case "$AUTH_MODE" in
        password|both)
            echo "PasswordAuth yes" > /etc/dropbear/dropbear.conf
            log_info "Password authentication: enabled"
            ;;
        key_only)
            # Password stays enabled until we verify the key works
            echo "PasswordAuth yes" > /etc/dropbear/dropbear.conf
            log_info "Password temporarily enabled (will disable after key verification)"
            ;;
    esac

    log_success "SSH config written (takes effect after reboot)"
    log_info "Your current SSH session is unaffected"
}

key_download_and_test() {
    if [[ "$AUTH_MODE" == "password" ]]; then
        return 0
    fi

    banner "SSH Key Download & Verification"

    # Kill any existing test server on 2222 (safe - not our session)
    kill_test_dropbear

    # Start a SEPARATE dropbear on port 2222 for key testing
    # This does NOT affect the main dropbear on port 22
    if ! /usr/sbin/dropbear -p 2222 2>/dev/null; then
        log_error "Could not start test SSH server on port 2222"
        return 1
    fi
    sleep 2

    log_success "Test SSH server running on port 2222"
    echo ""
    echo -e "${YELLOW}================================================================${NC}"
    echo -e "${BOLD}  IMPORTANT: Do these steps in a NEW terminal on your PC${NC}"
    echo -e "${BOLD}  Keep THIS terminal open until you confirm the key works!${NC}"
    echo -e "${YELLOW}================================================================${NC}"
    echo ""
    echo -e "${BOLD}STEP 1: Download the private key${NC}"
    echo ""
    echo "Open a NEW terminal on your computer and copy-paste the command for your OS:"
    echo ""
    echo -e "${CYAN}=== macOS / Linux ===${NC}"
    echo ""
    printf 'mkdir -p ~/.ssh && scp -P 2222 root@%s:%s ~/.ssh/id_batocera_%s && chmod 600 ~/.ssh/id_batocera_%s\n' \
        "$LOCAL_IP" "$OPENSSH_KEY" "$HOSTNAME" "$HOSTNAME"
    echo ""
    echo -e "${CYAN}=== Windows (PowerShell) ===${NC}"
    echo ""
    printf 'if (!(Test-Path "$env:USERPROFILE\\.ssh")) { New-Item -ItemType Directory -Path "$env:USERPROFILE\\.ssh" -Force }; scp -P 2222 root@%s:%s "$env:USERPROFILE\\.ssh\\id_batocera_%s"\n' \
        "$LOCAL_IP" "$OPENSSH_KEY" "$HOSTNAME"
    echo ""
    echo -e "${YELLOW}When prompted for a password, enter: ${BOLD}linux${NC}"
    echo ""

    read -rp "Press Enter after the key has been downloaded successfully..."

    echo ""
    echo -e "${BOLD}STEP 2: Test the key (should NOT ask for password)${NC}"
    echo ""
    echo "In the same NEW terminal, copy-paste this command:"
    echo ""
    echo -e "${CYAN}=== macOS / Linux ===${NC}"
    echo ""
    printf 'ssh -i ~/.ssh/id_batocera_%s -p 2222 -o PasswordAuthentication=no root@%s "echo Key_auth_success && exit"\n' \
        "$HOSTNAME" "$LOCAL_IP"
    echo ""
    echo -e "${CYAN}=== Windows (PowerShell) ===${NC}"
    echo ""
    printf 'ssh -i "$env:USERPROFILE\\.ssh\\id_batocera_%s" -p 2222 -o PasswordAuthentication=no root@%s "echo Key_auth_success && exit"\n' \
        "$HOSTNAME" "$LOCAL_IP"
    echo ""
    echo -e "${GREEN}If successful, you will see: Key_auth_success${NC}"
    echo -e "${RED}If it asks for a password or fails, the key did not work.${NC}"
    echo ""

    read -rp "Did you see 'Key_auth_success' (no password prompt)? (y/N): " KEY_WORKS

    # Clean up test server
    kill_test_dropbear

    if [[ "${KEY_WORKS,,}" =~ ^y ]]; then
        log_success "Key authentication verified!"

        if [[ "$AUTH_MODE" == "key_only" ]]; then
            echo "PasswordAuth no" > /etc/dropbear/dropbear.conf
            log_info "Password authentication will be disabled after reboot"
            echo ""
            echo -e "${YELLOW}IMPORTANT: Keep your key file safe! Without it, you cannot SSH in.${NC}"
        fi
        return 0
    else
        log_warn "Key authentication not confirmed"
        echo "PasswordAuth yes" > /etc/dropbear/dropbear.conf
        log_info "Keeping password authentication enabled for safety"

        echo ""
        echo -e "${BOLD}Troubleshooting:${NC}"
        echo ""
        echo "  1. Make sure the scp command completed without errors"
        echo ""
        echo "  2. Check the key file exists on your machine:"
        echo ""
        echo -e "${CYAN}     macOS/Linux:${NC}"
        printf '     ls -la ~/.ssh/id_batocera_%s\n' "$HOSTNAME"
        echo ""
        echo -e "${CYAN}     Windows (PowerShell):${NC}"
        printf '     Test-Path "$env:USERPROFILE\\.ssh\\id_batocera_%s"\n' "$HOSTNAME"
        echo ""
        echo "  3. On Windows, you may need to fix key permissions:"
        echo ""
        printf '     icacls "$env:USERPROFILE\\.ssh\\id_batocera_%s" /inheritance:r /grant:r "$env:USERNAME:R"\n' "$HOSTNAME"
        echo ""
        echo "  4. Try the test command again after fixing any issues"
        echo ""
        echo -e "${YELLOW}You can still SSH with password (root/linux) and retry key setup later.${NC}"

        return 1
    fi
}

########################################
# Samba setup
########################################
setup_samba() {
    banner "Configuring Samba"

    mkdir -p /etc/samba
    cat > /etc/samba/smb.conf << 'EOF'
[global]
workgroup = WORKGROUP
server string = Batocera Share
server min protocol = SMB2
security = user
map to guest = Bad User

[share]
path = /userdata
writeable = yes
guest ok = yes
create mask = 0666
directory mask = 0777
force user = root
EOF

    if ! pgrep -f "smbd" > /dev/null 2>&1; then
        if smbd -D -s /etc/samba/smb.conf 2>/dev/null; then
            log_success "Samba started"
        else
            log_warn "Samba failed to start (non-critical)"
        fi
    else
        log_info "Samba already running"
    fi
}

########################################
# Persistence (custom.sh)
########################################
create_persistence() {
    banner "Setting Up Persistence"

    log_info "Creating startup script..."

    cat > "$CUSTOM_SH" << 'CUSTOMEOF'
#!/bin/sh
# Batocera Tailscale & SSH persistence (v19.4)
# Auto-generated - do not edit manually

INSTALL_DIR="__INSTALL_DIR__"
BIN_DIR="__BIN_DIR__"
STATE_FILE="__STATE_FILE__"
SOCK_FILE="__SOCK_FILE__"
HOSTNAME="__HOSTNAME__"
TAG="__TAG__"
SUBNET_ENABLE="__SUBNET_ENABLE__"
SUBNET="__SUBNET__"
EXIT_NODE_ENABLE="__EXIT_NODE_ENABLE__"

log() { echo "$(date '+%Y-%m-%d %H:%M:%S') $1" >> /tmp/custom.log; }

log "Starting custom.sh"

# Create TUN device
mkdir -p /dev/net
[ ! -c /dev/net/tun ] && mknod /dev/net/tun c 10 200 && chmod 600 /dev/net/tun

# Bring up wireless if available
ip link set wlan0 up 2>/dev/null || true

# Firewall rules
iptables -F INPUT 2>/dev/null || true
iptables -P INPUT ACCEPT 2>/dev/null || true
iptables -A INPUT -p tcp --dport 22 -j ACCEPT 2>/dev/null || true
iptables -A INPUT -p tcp --dport 445 -j ACCEPT 2>/dev/null || true

# Start Dropbear SSH
if ! pgrep -f "dropbear" > /dev/null 2>&1; then
    /usr/sbin/dropbear -p 22 2>/dev/null && log "Dropbear started" || log "Dropbear failed"
else
    log "Dropbear already running"
fi

# Start Tailscale
mkdir -p /var/run/tailscale
ln -sf "$SOCK_FILE" /var/run/tailscale/tailscaled.sock 2>/dev/null

if ! pgrep -f "tailscaled" > /dev/null 2>&1; then
    "$BIN_DIR/tailscaled" \
        --state="$STATE_FILE" \
        --socket="$SOCK_FILE" \
        --tun=userspace-networking \
        >> /tmp/tailscaled.log 2>&1 &

    log "Tailscaled started, waiting for socket..."

    # Wait for socket
    for i in 1 2 3 4 5 6 7 8 9 10; do
        [ -S "$SOCK_FILE" ] && break
        sleep 2
    done

    if [ -f "$STATE_FILE" ]; then
        TAILSCALE_ARGS="--hostname=$HOSTNAME --accept-routes"
        [ -n "$TAG" ] && TAILSCALE_ARGS="$TAILSCALE_ARGS --advertise-tags=$TAG"
        [ "$SUBNET_ENABLE" = "yes" ] && TAILSCALE_ARGS="$TAILSCALE_ARGS --advertise-routes=$SUBNET"
        [ "$EXIT_NODE_ENABLE" = "yes" ] && TAILSCALE_ARGS="$TAILSCALE_ARGS --advertise-exit-node"

        sleep 3
        "$BIN_DIR/tailscale" --socket="$SOCK_FILE" up $TAILSCALE_ARGS >> /tmp/tailscaled.log 2>&1
        log "Tailscale up executed"
    fi
fi

# Start Samba (with delay to ensure network is up)
(
    sleep 20
    if [ -f /etc/samba/smb.conf ] && ! pgrep -f smbd > /dev/null 2>&1; then
        smbd -D -s /etc/samba/smb.conf 2>/dev/null && log "Samba started" || log "Samba failed"
    fi
) &

log "custom.sh completed"
CUSTOMEOF

    # Replace placeholders with actual values
    sed -i "s|__INSTALL_DIR__|$INSTALL_DIR|g" "$CUSTOM_SH"
    sed -i "s|__BIN_DIR__|$BIN_DIR|g" "$CUSTOM_SH"
    sed -i "s|__STATE_FILE__|$STATE_FILE|g" "$CUSTOM_SH"
    sed -i "s|__SOCK_FILE__|$SOCK_FILE|g" "$CUSTOM_SH"
    sed -i "s|__HOSTNAME__|$HOSTNAME|g" "$CUSTOM_SH"
    sed -i "s|__TAG__|$TAG|g" "$CUSTOM_SH"
    sed -i "s|__SUBNET_ENABLE__|$SUBNET_ENABLE|g" "$CUSTOM_SH"
    sed -i "s|__SUBNET__|$SUBNET|g" "$CUSTOM_SH"
    sed -i "s|__EXIT_NODE_ENABLE__|$EXIT_NODE_ENABLE|g" "$CUSTOM_SH"

    chmod +x "$CUSTOM_SH"
    log_success "Startup script created"

    log_info "Saving overlay..."
    if batocera-save-overlay; then
        log_success "Overlay saved"
    else
        log_error "Failed to save overlay"
        exit 1
    fi
}

########################################
# Summary
########################################
show_summary() {
    banner "Setup Complete!"

    echo -e "${BOLD}Configuration Summary:${NC}"
    echo ""
    echo -e "  Tailscale Version:  ${GREEN}$TAILSCALE_VERSION${NC}"
    echo -e "  Tailscale IP:       ${GREEN}$TAILSCALE_IP${NC}"
    echo -e "  Local IP:           ${GREEN}$LOCAL_IP${NC}"
    echo -e "  Hostname:           ${GREEN}$HOSTNAME${NC}"
    echo -e "  SSH Mode:           ${GREEN}$AUTH_MODE${NC}"
    [[ -n "$TAG" ]] && echo -e "  Tailscale Tag:      ${GREEN}$TAG${NC}"
    [[ "$SUBNET_ENABLE" == "yes" ]] && echo -e "  Subnet Routing:     ${GREEN}$SUBNET${NC}"
    [[ "$EXIT_NODE_ENABLE" == "yes" ]] && echo -e "  Exit Node:          ${GREEN}enabled${NC}"
    echo ""

    echo -e "${BOLD}After reboot, connect via:${NC}"
    echo ""
    if [[ "$AUTH_MODE" != "password" && -n "$OPENSSH_KEY" ]]; then
        echo -e "${CYAN}  macOS/Linux:${NC}"
        printf '    ssh -i ~/.ssh/id_batocera_%s root@%s\n' "$HOSTNAME" "$TAILSCALE_IP"
        echo ""
        echo -e "${CYAN}  Windows (PowerShell):${NC}"
        printf '    ssh -i "$env:USERPROFILE\\.ssh\\id_batocera_%s" root@%s\n' "$HOSTNAME" "$TAILSCALE_IP"
        echo ""
        if [[ "$AUTH_MODE" == "both" ]]; then
            echo -e "  Or with password: ${CYAN}ssh root@$TAILSCALE_IP${NC} (password: linux)"
            echo ""
        fi
    else
        echo -e "  SSH: ${CYAN}ssh root@$TAILSCALE_IP${NC}"
        echo -e "  Password: ${CYAN}linux${NC}"
        echo ""
    fi

    echo -e "${BOLD}Samba file sharing:${NC}"
    echo -e "  ${CYAN}\\\\$TAILSCALE_IP\\share${NC}"
    echo ""

    if [[ "$SUBNET_ENABLE" == "yes" || "$EXIT_NODE_ENABLE" == "yes" ]]; then
        echo -e "${YELLOW}Remember to approve subnet/exit node at:${NC}"
        echo -e "${CYAN}  https://login.tailscale.com/admin/machines${NC}"
        echo ""
    fi
}

########################################
# Main
########################################
main() {
    clear
    banner "Batocera Tailscale & SSH Setup v19.4"

    echo -e "${YELLOW}NOTE: This script will NOT disconnect your current SSH session.${NC}"
    echo -e "${YELLOW}You will test keys in a separate terminal before any changes take effect.${NC}"
    echo ""

    preflight_checks
    get_tailscale_version
    configure_tailscale
    configure_ssh
    configure_advanced

    echo ""
    echo -e "${BOLD}Ready to install with these settings:${NC}"
    echo "  Tailscale version: $TAILSCALE_VERSION"
    echo "  Hostname:          $HOSTNAME"
    echo "  SSH mode:          $AUTH_MODE"
    [[ -n "$TAG" ]] && echo "  Tag:               $TAG"
    [[ "$SUBNET_ENABLE" == "yes" ]] && echo "  Subnet:            $SUBNET"
    [[ "$EXIT_NODE_ENABLE" == "yes" ]] && echo "  Exit node:         yes"
    echo ""

    read -rp "Continue with installation? (Y/n): " CONFIRM
    if [[ "${CONFIRM,,}" =~ ^n ]]; then
        log_info "Installation cancelled"
        exit 0
    fi

    install_tailscale
    start_tailscale
    setup_ssh_keys
    configure_dropbear
    setup_samba
    key_download_and_test
    create_persistence
    show_summary

    read -rp "Reboot now to complete setup? (Y/n): " REBOOT
    if [[ ! "${REBOOT,,}" =~ ^n ]]; then
        log_info "Rebooting in 5 seconds..."
        sleep 5
        sync
        reboot -f || reboot
    else
        log_info "Reboot when ready to complete setup"
    fi
}

main "$@"
