#!/bin/bash
# Batocera Tailscale & SSH Setup - Hybrid Edition (v17.2)
# - Works on Batocera (Pi 5) with persistent /userdata
# - Installs or repairs Tailscale + optional SSH key flow + Samba
# - Tag is now OPTIONAL (default tag, custom tag, or NO TAG)
# - Adds self-update & backup/restore & status menu

set -euo pipefail

########################################
# Styling & Helpers
########################################
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

CHECKMARK="✓"
CROSSMARK="✗"
ARROW="→"
BULLET="•"
WARNING="⚠"
INFO="ℹ"

log() { echo -e "${1}[$(date '+%Y-%m-%d %H:%M:%S')] ${2}${NC} ${MAGENTA}⚡${NC}"; }

banner() {
    local text="$1"
    local width=60
    local border
    border=$(printf "%${width}s" '' | tr ' ' '=')
    echo -e "${BLUE}${border}${NC}"
    printf "${MAGENTA}%${width}s\n${NC}" "$text" | tr ' ' '.'
    echo -e "${BLUE}${border}${NC}"
}

progress_indicator() {
    local duration=$1
    local message="$2"
    local spin=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
    local i=0
    echo -ne "${CYAN}${message}...${NC} "
    for ((t=0; t<duration*10; t++)); do
        printf "\b${spin[i]}"
        i=$(( (i+1) % 10 ))
        sleep 0.1
    done
    echo -e "\b${GREEN}✓${NC}"
}

info_box()  { echo -e "${BLUE}${INFO}${NC}  ${WHITE}$1${NC}"; }
warn_box()  { echo -e "${YELLOW}${WARNING}${NC}  ${YELLOW}$1${NC}"; }
error_box() { echo -e "${RED}${CROSSMARK}${NC}  ${RED}$1${NC}"; }
success_box(){ echo -e "${GREEN}${CHECKMARK}${NC}  ${GREEN}$1${NC}"; }
step_box()  { echo -e "${CYAN}${ARROW}${NC}  ${CYAN}$1${NC}"; }

press_any_key() {
    echo -e "\n${DIM}Press any key to continue...${NC}"
    read -n 1 -s -r || true
}

########################################
# Paths & Defaults
########################################
INSTALL_DIR="/userdata/system/tailscale"
BIN_DIR="$INSTALL_DIR/bin"
SSH_DIR="/userdata/system/.ssh"
KEYS_DIR="$INSTALL_DIR/keys"
DROPBEAR_KEY="$SSH_DIR/id_dropbear"
STATE_FILE="$INSTALL_DIR/tailscaled.state"
SOCK_FILE="$INSTALL_DIR/tailscaled.sock"
CUSTOM_SH="/userdata/system/custom.sh"
CONFIG_FILE="$INSTALL_DIR/config.env"
BACKUP_DIR="$INSTALL_DIR/backups"
LOG_FILE="/tmp/tailscale_setup.log"

DEFAULT_TAG="tag:ssh-batocera"
LOCAL_SSH_PORT="22"
TEMP_SSH_PORT="2222"
MAX_LOG_SIZE=10485760  # 10MB

########################################
# Cleanup trap
########################################
cleanup_on_exit() {
    local exit_code=$?
    if [ $exit_code -ne 0 ]; then
        error_box "Script encountered an error. Check $LOG_FILE for details."
    fi
    rm -f "$INSTALL_DIR"/*.tgz.tmp 2>/dev/null || true
}

trap cleanup_on_exit EXIT

########################################
# Logging
########################################
init_logging() {
    mkdir -p "$(dirname "$LOG_FILE")"
    if [ -f "$LOG_FILE" ]; then
        local log_size
        log_size=$(stat -f%z "$LOG_FILE" 2>/dev/null || stat -c%s "$LOG_FILE" 2>/dev/null || echo 0)
        if [ "$log_size" -gt $MAX_LOG_SIZE ]; then
            mv "$LOG_FILE" "$LOG_FILE.old"
        fi
    fi
    echo "=== Tailscale Setup Log - $(date) ===" >> "$LOG_FILE"
}

log_exec() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXEC: $*" >> "$LOG_FILE"
    "$@" >> "$LOG_FILE" 2>&1
}

########################################
# Utility functions
########################################
need_root() {
    if [ "$(id -u)" -ne 0 ]; then
        error_box "This script must be run as root"
        exit 1
    fi
}

need_cmd() {
    if ! command -v "$1" >/dev/null 2>&1; then
        return 1
    fi
    return 0
}

net_ok() {
    if ! ping -c 3 8.8.8.8 &>/dev/null; then
        return 1
    fi
    return 0
}

wait_for_socket() {
    local socket="$1"
    local timeout="${2:-30}"
    local elapsed=0
    while [ $elapsed -lt $timeout ]; do
        if [ -S "$socket" ]; then
            return 0
        fi
        sleep 1
        elapsed=$((elapsed + 1))
    done
    return 1
}

validate_subnet() {
    local subnet="$1"
    if [[ ! "$subnet" =~ ^[0-9]{1,3}(\.[0-9]{1,3}){3}/[0-9]{1,2}$ ]]; then
        return 1
    fi
    local IFS='./'
    read -ra PARTS <<< "$subnet"
    for i in {0..3}; do
        if [ "${PARTS[$i]}" -gt 255 ]; then
            return 1
        fi
    done
    if [ "${PARTS[4]}" -gt 32 ]; then
        return 1
    fi
    return 0
}

validate_authkey()
